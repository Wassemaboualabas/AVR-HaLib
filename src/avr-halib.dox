/*
	- benefits
	- usage
	- development guidelines

directories erklären
ext
- external devices, extensions; peripherals
portmaps: common frequently used portmaps

Portmaps
Delegates

skaliert gut

Portmap:
- zentraler punkt, wo schnittstelle avr zu peripherie geschaffen wird
- protmap-definitionen können in C++ eingebettet werden, wenn "portmap nicht als bezeichner verwendet wird"


Coding-Conventions
- filenames lower case
- kleine Übersetzungseinheiten

Interrupts:
- Object-Methoden
- C-Funktionen

empfolene Compilerschalter:
verwende keine "int"s
http://www.mikrocontroller.net/articles/AVR-GCC-Codeoptimierung
http://www.atmel.com/dyn/resources/prod_documents/doc1497.pdf

enable interrupts! sei

kein volatile bei portmaps... statdessen sync... erklären
*/

/*!
\mainpage

\ref doc_intro

Concepts:
\li \ref doc_portmaps


AVR Classes:

External hardware abstraction classes:
\li \ref Button
\li \ref ButtonBlock
\li \ref Led
\li \ref LedBlock


\page doc_intro Introduction

\section doc_intro_features What is avr-avr-halib and why should I use it?

<b><i>avr-avr-halib is a library for writing efficient portable programs for AVR microcontrollers in C++ easily.</i></b>

TODO: examples (source code, sizes...)

(For more detailed information have a look at \ref doc_dev_guidlines.)


\section doc_intro_licence Under which terms of licence can I use this library?

TODO

\section doc_intro_supportet Which microcontrollers are supported?

At the moment there is full support for:
 * at90can128

Support for the following is in development:
 * atmega32

If you miss a platform: it's quite easy to port the library, because it is
designed for being portable. See \see doc_dev.


\section doc_intro_developers Who is developing this library?

EOS, Uni-Magdeburg
Philipp Werner	mail (at) philipp-werner (dot) info
Karl Fessel	

If you want to participate by writing new device classes or porting the library or several components to other AVR platforms just feel invited to do it.

\page doc_start Getting started

\section dec_start_examples Have a look at our example programs

./examples/applications/
makefile

\section doc_start_prog How to use avr-avr-halib?

-# Include the header files you need (see documentation of classes or <tt>./include/avr-halib/</tt>)
-# link with ... TODO


Why templates all-around?
What is this portmap-thing?



\page doc_portmaps Portmaps

\section doc_portmaps_intro What are portmaps and why should I use them?

In avr-halib portmaps are the connection between portable classes for external devices and the real hardware itself.
Inside a portmap you can map hardware pins to structure members with a meaningful name. You can also form virtual ports which be written and read like real ports, but it can consist of any pins you want. Moreover you can define properties to configure your device.

Using portmaps bring following advantages:
\li reusability, portability: If you want to use another AVR or another board with other pin configuration, you only have to exchange your portmap definitions. No changes in your code are necessary concerning access to external hardware.
\li readability: Once you know the concepts your code should be very readable.
\li efficiency: No extra RAM is needed! In addition optimal code generated by use of templates and bitfields, vports and enums.


\section doc_portmaps_use How to use portmaps?

For some hardware configurations there are complete portmap definition files in <tt>./include/avr-halib/portmaps/</tt>. If there are no portmap definitions for your hardware have a look at \ref doc_portmaps_syntax.

To use a portmap you have to generate C++ code out of the portmap definition by invoking the avr-halib portmap generator (<tt>./tools/portmapgen/avr-halib-pmg</tt>). After you linked it into your <tt>PATH</tt>, you can get halp about the usage by running <tt>avr-halib-pmg -h</tt>. The easiest way to handle portmap generation is to include it into you Makefile (see <tt>./include/avr-halib/portmaps/Makefile</tt>).

Once you got the portmaps C++ code you have to include it where you want to use the portmap. After that you can use the portmaps to bind instances of external hardware classes to the real hardware:

\code
// File containing C++ code for portmap Led0
#include "avr-halib/portmaps/robbyboard.h"

int main() 
{
	// Bind class Led to hardware specified by portmap Led0
	Led<Led0> led0;
	
	// Just use object led0... you needn't think about the portmap any more
	led0.setOn();

	// ...
}
\endcode

External hardware classes, as most classes in avr-halib, get their configuration as a template parameter. Thus, if you've turned optimization on when compiling, we get very efficient code that contains no unnecessary overhead.

If you want to use another LED in function of <tt>led0</tt> or you want to use this code on a board where your LED is connected to another PIN, you only have to replace the portmap. You can do that either in declaration of the object <tt>led0</tt> or by exchanging the definition of the portmap <tt>Led0</tt>.



\section doc_portmaps_syntax How to write a portmap?

To use a external hardware class you have to define a portmap following the specification of the class: map the functional pins on your hardware pins and define the behavior of you external hardware. For this purpose we have developed a simple portmap definition syntax. It can be used in a seperate portmap definition file or be embedded in you C++ code. After writing portmap definitions you have to generate valid C++ code out of it using the avr-halib portmap generator (see section above).

A (very simple) portmap definition looks like this:
\code
portmap Led0 for at90can128
{
	pin led: a 0;
	property onLevel = true;
};
\endcode

Every portmap definition starts with the keyword <tt>portmap</tt>. After that you can specify the microcontroller which this portmap is written for. If you do not specify it, you have to make up for it when invoking the portmap generator. The content of the portmap is surrounded by braces and closed by a semicolon. Everything outside these blocks is copied by the portmap generator. The portmap definitions are replaced by valid C++ code.

Inside the portmap body you can define pins, properties and vports. A <tt>pin</tt> assigns a name to one hardware pin you have to specify. The keyword <tt>pins</tt> can be used to assign a name to some hardware pins of one port which adjoin to each other. A vport (virtual port) is a collection of <tt>pin</tt>s and <tt>pins</tt>' that makes it easy to access multiple pins at the same time. Furthermore you can specify configuration constants by using the keyword <tt>property</tt>.



\section doc_portmaps_grammar Syntax of a portmap definition
<pre>
<i>\<Portmap\>:</i>
	portmap <i>\<Identifier</i>\> [for <i>\<Controller\></i>] { <i>\<PortmapEntry\></i>* };

<i>\<PortmapEntry\>:</i>
	<i>\<Pin\></i>
	<i>\<Pins\></i>
	property <i>\<Identifier\></i> = <i>\<BooleanOrIntegerValue\></i>;
	vport <i>\<Identifier\></i> { <i>\<VPortIdList\></i> };

<i>\<VPortIdList\></i>
	(empty-expression)
	<i>\<PinIdentifier\></i>, <i>\<VPortIdList\></i>
	<i>\<PinsIdentifier\></i>, <i>\<VPortIdList\></i>

<i>\<Pin\>:</i>
	pin <i>\<Identifier\></i> : <i>\<PortCharacter\></i> <i>\<PinNumber\></i>;

<i>\<Pins\>:</i>
	pins <i>\<Identifier\></i> : <i>\<PortCharacter\></i> <i>\<FirstPinNumber\></i>-<i>\<LastPinNumber\></i>;
</pre>

Identifiers inside a portmap must be unique. Hardware pins can only be assigned to one identifier.



\section doc_portmaps_magic How do portmaps work?

In our portmap concept we utilized that AVR ports are memory mapped. We made a portmap to a structre which makes extensive use of unions and bitfields to map pin identifiers to specified offsets. We you do not create a real instance but use the portmap structure as an overlay for the memory which is mapped to the hardware. Therefore you can access hardware pins without overhead through a nice interface.



\section doc_portmaps_class How to use portmaps for writing a portable device class?

To write a portable class for external hardware you should ...

\li ... have a look at some examples (<tt>./include/avr-halib/ext/*</tt>)
\li ... specify your portmap structure. Which pins and properties do you need? Maybe it's reasonable to use a vport?
\li ... write a template class that takes a portmap as template parameter.
\li ... include <tt>"avr-halib/avr/portmap.h"</tt> and use the macro \ref UsePortmap in every function to create "an instance" of your portmap
\li ... have a look at the macro \ref SyncPortmap if you use pins for input.
\li ... write documentation for your class (including specification for the expected portmap). See <tt>./include/avr-halib/ext/button.h</tt>, for example.




\page doc_dev Development of the library

\section doc_dev_guidelines Development guildlines

For developing this library we decided to pay much attention to following aspects:
- \b flexibility and \b reusability: This library should be useful for as many applications as possible.
- \b efficiency: It should be simple to write sources easy to read that compiles to a fast, small and memory saving program.
- \b portability: It should be as easy as possible to port prgrams written with this library and the library itself to other AVR microcontrollers.

To reach this goals we decided...
- to use \b C++: object oriented programming avoiding virtual functions and other features of C++ that are expensive
- templates and so-called \ref doc_portmaps: allows flexibility and portability while generating only the code really needed

\section doc_dev_regmaps Register maps


\page doc_cdevices Charcter devices

Da viele Ein- und Ausgabeschnittstellen Zeichen-basiert funktionieren, stellen
wir f�r all diese Ger�te ein Interface <tt>CDevice</tt> zur Verf�gung, so dass
diese einheitlich angesprochen werden k�nnen. Das Interface erg�nzt Ger�te, die
nur einzelne Zeichen ausgeben k�nne um die M�glichkeit zur Ausgabe von
C-Zeichenketten und Zahlen. Die bisher einzige ausgereifte und von uns eingesetzte
Implementierung dieses Interfaces stellt Uart dar.

\page doc_delegates Delegates

\page doc_interrupt Interrupts

In unserer Hardwarebibliothek wird jeder Interrupt-Typ durch eine abstrakte Klasse
repr�sentiert. Diese definiert eine abstrakte Methode, die bei Ausl�sung des Interrupts
als Interrupt-Service-Routine aufgerufen wird. Auf diesem Wege lassen sich Interrupts
bequem auf Objekt-Ebene behandeln. Bei der Interrupt-Behandlung kann also direkt auf
Methoden oder Objekt-Variablen zur�ckgegriffen werden. \n
Um nun einen konkreten Interrupt zu behandeln, muss zuerst die entsprechende abstrakte
Klasse deklariert und implementiert werden, dies geschieht bequem �ber die Makros
#DECLARE_INTERRUPT_CLASS(classname) und #IMPLEMENT_INTERRUPT_CLASS(sig,classname).
Im folgenden muss dann die Klasse, deren Objekt ein Interrupt behandeln soll
von der Interrupt-Klasse erben und die ISR definieren. Die ISR ist wie die
Interrupt-Klasse, jedoch um ein vorangestelltes <tt>on</tt> erg�nzt, benannt. \n

Zur Verwenung hier ein Beispiel: \n

\code
// beispiel.h:

#include "interrupt.h"

DECLARE_INTERRUPT_CLASS(Interrupt1)			

class Beispiel : public Interrupt1
{
public:
	void onInterrupt1();
};
\endcode

\code
// beispiel.cpp:

#include "beispiel.h"

IMPLEMENT_INTERRUPT_CLASS(SIG_INTERRUPT1, Interrupt1)	// External Interrupt Request 1

void Beispiel::onInterrupt1()
{
	// Hier Interrupt behandeln...
}
\endcode

Die Interrupt-Behandlung werden beispielsweise auch in den Klassen zur Abstraktion der
Hardware-Timer des ATmega32 eingesetzt.


\page doc_timer Timer

<table><tr><td>
Anmerkung zur Versionsgeschichte: \n
Anfangs wollten wir sehr flexible Timerklassen entwickeln, die Zeitangaben in
gebr�uchlichen Zeiteinheiten wie Millisekunden unterst�tzen sollten. Au�erdem
sollten mehre "Klienten" pro Hardware-Timer bediehnt werden k�nnen. Letztes
war auch schon im wesentlichen implementiert, jedoch haben sich die
entstandenen Timer-Klassen alles andere als intuitiv handhaben lassen,
so dass wir uns im Timerbereich radikal vom �berfeaturungsgedanken abgewendet
haben. Die neu geschriebenen Klassen sind dem entsprechend sehr einfach
ausgefallen und im wesentlichen an den Anforderungen der Anwendungsaufgabe
orientiert.
</td></tr></table>

Bei unserer Timer-Abstraktion handelt es sich nicht um eine vollst�ndige
Implementierung aller vom ATmega32 unterst�tzen Timer-Modi. Die Bibliothek
stellt im Moment nur f�r jeden der drei Timer eine Timer-Klasse bereit,
die die jeweils verf�gbaren Prescaling-Modi unterst�tzt und in der
eingestellten Prescaler-Frequenz die Timer-Behandlungsroutine
aufruft. Da alle Timer �ber eine Timer-Behandlungsroutine verf�gen gibt es
f�r Timer eine gemeinsame abstrakte Basisklasse, die diese Routine
(<tt>void onTimer()</tt>) abstrakt definiert.
Um einen Timer zu verwenden leitet man �hnlich wie bei der Interrupt-Behandlung
die Klasse, deren Objekt den Timer verwenden soll, von der entsprechenden Timer-
Klasse ab und definiert dann eine Handler-Methode <tt>void onTimer()</tt>.


Zur Verwenung hier ein Beispiel:

\code
// beispiel2.h:

#include "timer.h"

class Beispiel2 : public Timer1
{
public:
	void onTimer();
};
\endcode

\code
// beispiel2.cpp:

#include "beispiel2.h"

void Beispiel2::onTimer()
{
	// Hier Timer-Event behandeln...
}

int main()
{
	Beispiel2 b;
	b.start(TIMER_PS_1024);
	// ...
	b.stop();
}
\endcode

Die Bibliothek l�sst sich leich f�r andere durch die Hardware unsterst�tzte
Timer-Modi erweitern, indem man neue Timer-Klassen von der Timer-Basisklasse ableitet
und Implementiert.


\subsection avr-halibdigitalout Digitale Ein- und Ausg�nge

Das BobbyBoard verf�gt �ber mehrere digitale Ein- und Ausg�nge, die �ber die Ports
des ATmega32 angesprochen werden k�nnen. Die LEDs und Buttons des BobbyBoards
lassen sich �ber die Ports des ATmega32 setzen bzw. abfragen. Um diesen
Gemeinsamkeiten gerecht zu werden haben wir die Klassen DigitalIn und
DigitalOut entwickelt, die das Konzept eines digitalen Ein- bzw. Ausgangs
abbilden. Beide Klassen haben als wesentliche Eigenschaft eine Referenz auf
den Port, auf dem sie operieren und eine Bitmaske, die die Bits des Ports kennzeichnet,
auf dem die Ein- bzw. Ausg�nge liegen. Die Konstrukoren nehmen als weitere Argumente
Referenzen auf andere Register des ATmega32, �ber die sich die einzelnen Pins der
Ports als Ein- bzw. Ausg�nge konfigurieren lassen.

Als speziellen digitalen Ausgang haben wir die Klasse Led von DigitalOut abgeleitet.
Sie erweitert den digitalen Ausgang jedoch um ein paar besser benannte Methoden, die
Methoden der Basisklasse aufrufen.

Analog dazu haben wir Button als speziellen digitalen Eingang definiert.

Bei der Arbeit mit dem Roboter hat sich jedoch gezeigt, dass es oft praktisch ist
alle LEDs mit einem Mal auf ein Muster zu setzen. Aus diesem Grund haben wir die Bibliothek um die
Klasse LedBlock erweitert, �ber die sich mehrere LEDs an einem Port mit einem
Methodenaufruf setzen lassen.

Analog dazu lassen sich �ber ButtonBlock mehrere Buttons an einem Port mit einem
Methodenaufruf abfragen.


\subsection avr-halibsensoren Die Sensoren

Alle Sensoren (sowohl digitale als auch analoge) k�nnen zum Beispiel zur
Listenverarbeitung �ber ein gemeinsames Inferface Sensor
angesprochen werden. Die Sensoren werden in zwei verschiedene Klassen
eingeordnet DigitalSensor und AnalogSensor. Da die
Analog-Digital-Wandlung viel Zeit in Anspruch nimmt kann die Abfrage der
Sensoren, altenativ zur Abfrage mit starten und warten (<tt>register_t getValue()</tt>),
auch in Auftrag (<tt>virtual bool startGetValue()</tt>) und Ergebnissabfrage
(<tt>register_t getCachedValue()</tt>) unterteilt werden, um die Arbeitszeit
des AD-Wandlers f�r andere Berechnungen zu nutzen.


\code
// beispielsensor1.cpp:

#include "sensor.h"
..
Sensor * sensor = & AnalogSensor(0);

void foo()
{
	// starten 
	if(sensor->startGetValue())
	{
		// Zeit kann beliebig genutzt werden
	
		// Sicherstellen, dass der Wert verf�gbar ist
		while(sensor->isReady());
	
		// Wert lesen
		register_t a = sensor->getCachedValue();
		
		// ...
	}
	else
	{
		// Hier Auftrags NichtAnnahme behandeln Grund z.B.
		// Analog-Digital-Wandler belegt
	
	}
}

\endcode

\code
// beispielsensor2.cpp:

#include "sensor.h"

Sensor * sensor = & AnalogSensor(0);

void foo2()
{
	// Wert lesen
	register_t a = sensor->getValue();

	// ...
}
\endcode

\subsection avr-halibmotoren Die Motoren

Unsere selbst geschriebene Abstraktion f�r Motoren (Motor) unterst�tzt die Verwendung
beliebiger Ports und Pin-Konfigurationen zur Ansteuerung der Motoren, �hnlich
wie DigitalOut. Zum Betreiben der Motoren in einer definierten Geschwindigkeit,
die kleiner als die Maximalgeschwindigkeit ist, wurde eine Software-Plusweiten-
Modulation programmiert, die keine Begrenzung (abgesehen von den Resourcen)
f�r die Anzahl der betriebenen Motoren besitzt, da die Motoren in einer
verketteten Liste organisiert werden. F�r die PWM wird Timer2 reserviert,
dieser kann also bei Verwenung eines Motors nicht anderweitig genutzt werden.

Au�erdem verf�gt der Motor �ber eine Kalibrierungsfunktion, die aber aus Zeitmangel
nicht ausreichend getestet werden konnte und daher in der Aufgabenl�sung nicht
verwendet wurde.






\subsection avr-halibrest Andere n�tzliche Klassen

Im Rahmen der Implementierung diverser Char-Devices entstand auch die Template-Klasse
QueueBuffer als Bestandteil der Hardware-Bibliothek. Diese hat zwar nicht direkt
was mit Hardware-Abstraktion zu tun, k�nnte sich aber trotzdem f�r so manche
Anwendung als brauchbar erweisen. Zur L�sung der Aufgabe fand sie auch Verwendung
in Terminal und ReverseDijkstraMap.

*/

/*!
\page doc_dev Erweiterung unserer Hardware-Abstraktionsbibliothek


\section avr-haliberweiterungkomponenten Erweiterung der Bibliothek um weitere Komponenten

Die Bibliothek kann leicht um weitere Hardwarekomponenten erweitert werden, indem
entsprechende Dateien in die Verzeichnisstruktur eingebaut werden. Dabei ist jedoch
nach M�glichkeit darauf zu achten, die verwendeten Namenskonventionen zu beachten:
im Wesentlichen Gro�schreibung von Klassennamen und Kleinschreibung von
Funktionsnamen und Variablen. Dabei werden bei zusammengesetzten Worten neue Worte
immer gro� begonnen (<tt>eineVariable</tt>, <tt>EineKlasse</tt>). Au�erdem sollte
die r�umliche Aufteilung von gemeinsamem und plattformspezifischem Code beibehalten
werden und es sollten die in <tt>avr-halib/config.h</tt> definierten Datentypen verwendet
werden, um die \ref avr-haliberweiterungplattformen zu erleichtern.


\section avr-haliberweiterungplattformen Erweiterung der Bibliothek f�r andere Plattformen

Der Quellcode unserer Hardware-Abstraktions-Bibliothek ist so organisiert, dass sich
die Bibliothek recht einfach f�r die Unterst�tzung anderer Plattformen erweitern
l�sst. Plattformspezifischer Code befindet sich in jeweils einem eigenen Unterverzeichnis
von <tt>avr-halib/</tt>. So z.B. der Code f�r den ATmega32 in <tt>halib/atmega32/</tt>.
Um die Bibliothek zu erweitern, muss zuerst ein solches Unterverzeichnis angelegt werden.
In diesem sollten dann die zu unterst�tzenden Features implementiert werden (Beispiel
siehe <tt>avr-halib/atmega32/*.*</tt>). Um die Portierung f�r den entsprechenden
Microcontroller bequem per Compiler-Zielger�t-Parameter verwenden zu k�nnen,
m�ssen jetzt zum einem gewisse Hardware-Paramter f�r die Plattform definiert werden.
Dies geschieht in der Datei <tt>avr-halib/config.h</tt>, die hier um eine fiktive Plattform
ABc1234 von XYZ erweitert wurde, die �ber 16-Bit-Register verf�gt.

\code
// file: avr-halib/config.h:

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
typedef uint8_t port_t;
typedef uint8_t register_t;
#elif defined (__XYZ_ABc1234__)		// erg�nzt die neue Plattform
typedef uint8_t port_t;
typedef uint16_t register_t;
#else
# error "device type not defined or not supportet"
#endif

// ...
\endcode

Au�erdem muss in den allgemeinen Dateien f�r die unterst�tzten Komponenten der
Verweis zu der jeweiligen Plattform-Implementierung eingef�gt werden. In diesem
Beispiel wird die Timer-Implementierung f�r die fiktive Plattform ABc1234 eingebunden.

\code
// avr-halib/timer.cpp

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
# include "atmega32/timer.cpp"
#elif defined (__XYZ_ABc1234__)		// erg�nzt die neue Plattform
# include "abc1234/timer.cpp"
#else
# error "device type not defined or not supportet"
#endif
\endcode

\code
// avr-halib/timer.h

// ...

#if defined (__AVR_ATmega32__)		// bereits vorhanden
# include "atmega32/timer.h"
#elif defined (__XYZ_ABc1234__)		// erg�nzt die neue Plattform
# include "abc1234/timer.h"
#else
# error "device type not defined or not supportet"
#endif
\endcode

*/
 
