
- Interrupt-Delegates direkt in IVT
- Uart/CDevice synchron, waiting flush
- Konzepte überall übernehmen
- Timer-Implementierung: verschiedene Features
- I2C, SPI


- CPU-Geschwindigkeitsmakros-Verwendung / delay / Timer anpassen zu enum

- avr komplettieren

- DefineInterrupt für atmega32, doku zu interrupts
- #ifdef DOXYGEN oder so ähnlich, für CDevice::get() etc. (Funktionen, die von Template-Parameter-Basisklasse benötigt

- Timer-Regmaps: waveform generation mode ändern! etc. modi durch einzelne bits setzen
- Karl: Sensoren/ADC doku
- Delegate auch allgemein (z.B. für EggTimer (onEggTimer())), Doku dazu
- DigitalIn-Test

rückgabewert immmer fehlercodes
rm define -> rm per function (less code)
volatile nur wenn nötig


- Datei mit Sachen, die erst bei Bibliotheksnutzung übersetzbar (z.B. CPU-Frequenzabhängiges wie delay) und GenInterrupts in eine Cpp (generiert?); oder je eine Bibliothek übersetzen mit Parametern (z.B. CPU-Frequenz)
- Delay: Doku Beispiel ledblock.cpp, viele-übersetzungseinheiten-fähig machen
- CPU-Frequ. als enum?
- Klassendoku wie Led/LedBlock/Button
- Interrupts Use/Gen-Problematik, wohin damit?
- Doku: mögliche Regmaps für verschiedene Devices + ggf. gebrauchte Interrupts

- restructuring
	- prozessor/peri aufspalten
	- konkrete Benennung der Peripherie, Dokumentation der von der Klasse verwendeten/unterstützen Modi
- portmaps
- english!

- rename: avr-halib
- Lizenz

Idee:
- Interrupt-Deaktivierung per defines, für die tool automatisch eine config-datei generiert (da auch taktfrequenz rein?)


PortMap-Generator:
- Syntax "C++-kompatibel", so dass Einbettung in C++ möglich

 
Testprogramme

Halib:
- delay-fkt
- Timer allgemeiner
- MOtor-Regelung
- examples in Doku verlinken

Taru:
- auf at90can128 zum laufen bringen, für Vorführungen fertig machen
- Makefile für mehrere Plattformen


---------snip
// TODO: Einordnen
template <class Class>
	class oneInstance
{
	public:
	static Class getInstance()
	{
		static Class instance;
		return instance;
	}
};
---------snap
