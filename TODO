- Interrupt-Delegates direkt in IVT
- Uart/CDevice synchron, waiting flush
- Konzepte überall übernehmen
aufgeschoben - I2C, SPI
- Timer-Implementierung: verschiedene Features (z.B. input capture) implementieren (+ Ergänzung entsprechende Regmaps) und docs
- isr.cpp und andere examples aufmöbeln
- interrupt-mask-registermap

- CPU-Geschwindigkeitsmakros-Verwendung / delay / Timer anpassen zu enum

- avr komplettieren

- DefineInterrupt für atmega32, doku zu interrupts

- Timer-Regmaps: waveform generation mode ändern! etc. modi durch einzelne bits setzen
- Karl: Sensoren/ADC doku



- Datei mit Sachen, die erst bei Bibliotheksnutzung übersetzbar (z.B. CPU-Frequenzabhängiges wie delay) und GenInterrupts in eine Cpp (generiert?); oder je eine Bibliothek übersetzen mit Parametern (z.B. CPU-Frequenz)
- Delay: Doku Beispiel ledblock.cpp, viele-übersetzungseinheiten-fähig machen
- CPU-Frequ. als enum?
- Klassendoku wie Led/LedBlock/Button
- Interrupts Use/Gen-Problematik, wohin damit?
- Doku: mögliche Regmaps für verschiedene Devices + ggf. gebrauchte Interrupts

- restructuring
	- prozessor/peri aufspalten
	- konkrete Benennung der Peripherie, Dokumentation der von der Klasse verwendeten/unterstützen Modi
- portmaps
- english!

Testprogramme

- examples in Doku verlinken


Idee:
- Interrupt-Deaktivierung per defines, für die tool automatisch eine config-datei generiert (da auch taktfrequenz rein?)


Taru:
- auf at90can128 zum laufen bringen, für Vorführungen fertig machen
- Makefile für mehrere Plattformen


---------snip
// TODO: Einordnen
template <class Class>
	class oneInstance
{
	public:
	static Class getInstance()
	{
		static Class instance;
		return instance;
	}
};
---------snap
