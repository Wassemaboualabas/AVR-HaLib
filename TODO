- CDevice < Uart <Uart1> > statt virtueller Funktionen
- DEFINE für keine virtuellen Destruktoren
- anonyme platzhalter __base, __pad0 (private)
- referenzen lokal
- kein volatile bei jeder objektvariable
- DefineInterrupt für atmega32, doku zu interrupts

- Timer-Regmaps: waveform generation mode ändern! etc. modi durch einzelne bits setzen
- include/halib/avr/at*, src/avr/at* ausmisten (nach ext, was nicht avr)
- Karl: Sensoren/ADC
- Delegate auch allgemein (z.B. für EggTimer (onEggTimer())), Doku dazu

rückgabewert immmer fehlercodes
rm define -> rm per function (less code)
volatile nur wenn nötig


- Datei mit Sachen, die erst bei Bibliotheksnutzung übersetzbar (z.B. CPU-Frequenzabhängiges wie delay) und GenInterrupts in eine Cpp (generiert?); oder je eine Bibliothek übersetzen mit Parametern (z.B. CPU-Frequenz)
- Delay: Doku Beispiel ledblock.cpp, viele-übersetzungseinheiten-fähig machen
- CPU-Frequ. als enum?
- Klassendoku wie Led/LedBlock/Button
- Interrupts Use/Gen-Problematik, wohin damit?
- Doku: mögliche Regmaps für verschiedene Devices + ggf. gebrauchte Interrupts

- restructuring
	- prozessor/peri aufspalten
	- konkrete Benennung der Peripherie, Dokumentation der von der Klasse verwendeten/unterstützen Modi
- portmaps
- english!

- rename: avr-halib
- Lizenz

Idee:
- Interrupt-Deaktivierung per defines, für die tool automatisch eine config-datei generiert (da auch taktfrequenz rein?)


PortMap-Generator:
- Syntax "C++-kompatibel", so dass Einbettung in C++ möglich

 
Testprogramme

Halib:
- kleine Übersetzungseinheiten
- delay-fkt
- rekursive? makefiles
- problem: timer-interrupts bei generischem Motor sobald motor.o eingelinkt
- Timer allgemeiner
- Sensoren verbessern (Referenzspannung flexibel, evt. Templates (auch 10-bit-Modus))
- MOtor-Regelung
- examples in Doku verlinken

Taru:
- auf at90can128 zum laufen bringen, für Vorführungen fertig machen
- Makefile für mehrere Plattformen

