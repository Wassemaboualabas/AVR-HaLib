Übergangsmakefile für halib & alles gegen lib linken, Uart verwenden einfach machen, EggTimer debuggen

- include/halib/avr/at*, src/avr/at* ausmisten (nach ext, was nicht avr)
- Karl: Sensoren/ADC
- Uart: Baudrate als Template-Parameter
- CPU-Frequ. als enum?
- Phil: Button, Led (Portmap-Erweiterung: enums als Config-Parameter)

- QueueBuffer.get() anpassen null nicht als rückgabe wert für leere queue verwenden  entweder rückgabewert ist immer fehlerstatus oder immer wert (möglicherweise struct aus fehler status und wert (währe wahrscheinlich komplizierter in der verwendung))
mögliche Alternativen:	- wert = get(&fehler)  sonst unüblich aber mit am meisten ähnlichkeit zu bestehenden lösung
			- fehler = get(&wert)  übliche variante
			- zukünftig nur if (!isEmpty()) wert = get(); verwenden (in Uart einbauen)
			- (wert, fehler) = get() wert-fehler-tupel (aufwändig und unüblich)


- restructuring
	- prozessor/peri aufspalten
	- konkrete Benennung der Peripherie, Dokumentation der von der Klasse verwendeten/unterstützen Modi
- portmaps
- Interrupts austauschbar (ASM Fkt-Call mit this-pointer)
- english!

- rename: avr-halib
- Lizenz

Idee:
Interrupt-Deaktivierung per defines, für die tool automatisch eine config-datei generiert (da auch taktfrequenz rein?)


PortMap-Generator:
- Syntax "C++-kompatibel", so dass Einbettung in C++ möglich

 
Testprogramme

Halib:
- Baudrate, µp-frequ
- kleine Übersetzungseinheiten
- delay-fkt
- rekursive makefiles
- problem: timer-interrupts bei generischem Motor sobald motor.o eingelinkt
- Timer allgemeiner
- Sensoren verbessern (Referenzspannung flexibel, evt. Templates (auch 10-bit-Modus))
- MOtor-Regelung
- examples in Doku verlinken

Taru:
- auf at90can128 zum laufen bringen, für Vorführungen fertig machen
- Makefile für mehrere Plattformen

