 /**

\page doc_portmaps Portmaps

\section doc_portmaps_intro What are portmaps and why should I use them?

In avr-halib portmaps are the connection between portable classes for external devices and the real hardware itself.
Inside a portmap you can map hardware pins to structure members with a meaningful name. You can also form virtual ports which be written and read like real ports, but it can consist of any pins you want. Moreover you can define properties to configure your device.

Using portmaps bring following advantages:
\li reusability, portability: If you want to use another AVR or another board with other pin configuration, you only have to exchange your portmap definitions. No changes in your code are necessary concerning access to external hardware.
\li readability: Once you know the concepts your code should be very readable.
\li efficiency: No extra RAM is needed! In addition optimal code generated by use of templates and bitfields, vports and enums.


\section doc_portmaps_use How to use portmaps?

For some hardware configurations there are complete portmap definition files in <tt>./include/avr-halib/portmaps/</tt>. If there are no portmap definitions for your hardware have a look at \ref doc_portmaps_syntax.

To use a portmap you have to generate C++ code out of the portmap definition by invoking the avr-halib portmap generator (<tt>./tools/portmapgen/avr-halib-pmg</tt>). After you linked it into your <tt>PATH</tt>, you can get halp about the usage by running <tt>avr-halib-pmg -h</tt>. The easiest way to handle portmap generation is to include it into you Makefile (see <tt>./include/avr-halib/portmaps/Makefile</tt>).

Once you got the portmaps C++ code you have to include it where you want to use the portmap. After that you can use the portmaps to bind instances of external hardware classes to the real hardware:

\code
// File containing C++ code for portmap Led0
#include "avr-halib/portmaps/robbyboard.h"

int main() 
{
	// Bind class Led to hardware specified by portmap Led0
	Led<Led0> led0;
	
	// Just use object led0... you needn't think about the portmap any more
	led0.setOn();

	// ...
}
\endcode

External hardware classes, as most classes in avr-halib, get their configuration as a template parameter. Thus, if you've turned optimization on when compiling, we get very efficient code that contains no unnecessary overhead.

If you want to use another LED in function of <tt>led0</tt> or you want to use this code on a board where your LED is connected to another PIN, you only have to replace the portmap. You can do that either in declaration of the object <tt>led0</tt> or by exchanging the definition of the portmap <tt>Led0</tt>.



\section doc_portmaps_syntax How to write a portmap?

To use a external hardware class you have to define a portmap following the specification of the class: map the functional pins on your hardware pins and define the behavior of you external hardware. For this purpose we have developed a simple portmap definition syntax. It can be used in a seperate portmap definition file or be embedded in you C++ code (<a href="digitalio_8cpp-example.html">Example</a>). After writing portmap definitions you have to generate valid C++ code out of it using the avr-halib portmap generator (see section above).

A (very simple) portmap definition looks like this:
\code
portmap Led0 for at90can128
{
	pin led: a 0;
	property onLevel = true;
};
\endcode

Every portmap definition starts with the keyword <tt>portmap</tt>. After that you can specify the microcontroller which this portmap is written for. If you do not specify it, you have to make up for it when invoking the portmap generator. The content of the portmap is surrounded by braces and closed by a semicolon. Everything outside these blocks is copied by the portmap generator. The portmap definitions are replaced by valid C++ code.

Inside the portmap body you can define pins, properties and vports. A <tt>pin</tt> assigns a name to one hardware pin you have to specify. The keyword <tt>pins</tt> can be used to assign a name to some hardware pins of one port which adjoin to each other. A vport (virtual port) is a collection of <tt>pin</tt>s and <tt>pins</tt>' that makes it easy to access multiple pins at the same time. Furthermore you can specify configuration constants by using the keyword <tt>property</tt>.



\section doc_portmaps_grammar Syntax of a portmap definition
<pre>
<i>\<Portmap\>:</i>
	portmap <i>\<Identifier</i>\> [for <i>\<Controller\></i>] { <i>\<PortmapEntry\></i>* };

<i>\<PortmapEntry\>:</i>
	<i>\<Pin\></i>
	<i>\<Pins\></i>
	property <i>\<Identifier\></i> = <i>\<BooleanOrIntegerValue\></i>;
	vport <i>\<Identifier\></i> { <i>\<VPortIdList\></i> };

<i>\<VPortIdList\></i>
	(empty-expression)
	<i>\<PinIdentifier\></i>, <i>\<VPortIdList\></i>
	<i>\<PinsIdentifier\></i>, <i>\<VPortIdList\></i>

<i>\<Pin\>:</i>
	pin <i>\<Identifier\></i> : <i>\<PortCharacter\></i> <i>\<PinNumber\></i>;

<i>\<Pins\>:</i>
	pins <i>\<Identifier\></i> : <i>\<PortCharacter\></i> <i>\<FirstPinNumber\></i>-<i>\<LastPinNumber\></i>;
</pre>

Identifiers inside a portmap must be unique. Hardware pins can only be assigned to one identifier.



\section doc_portmaps_magic How do portmaps work?

In our portmap concept we utilized that AVR ports are memory mapped. We made a portmap to a structre which makes extensive use of unions and bitfields to map pin identifiers to specified offsets. We you do not create a real instance but use the portmap structure as an overlay for the memory which is mapped to the hardware. Therefore you can access hardware pins without overhead through a nice interface.



\section doc_portmaps_class How to use portmaps for writing a portable device class?

To write a portable class for external hardware you should ...

\li ... have a look at some examples (<tt>./include/avr-halib/ext/*</tt>)
\li ... specify your portmap structure. Which pins and properties do you need? Maybe it's reasonable to use a vport?
\li ... write a template class that takes a portmap as template parameter.
\li ... include <tt>"avr-halib/avr/portmap.h"</tt> and use the macro \ref UsePortmap in every function to create "an instance" of your portmap
\li ... have a look at the macro \ref SyncPortmap if you use pins for input.
\li ... write documentation for your class (including specification for the expected portmap). See <tt>./include/avr-halib/ext/button.h</tt>, for example.

*/