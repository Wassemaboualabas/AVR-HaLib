% German slides for a presentation to introduce avr-halib

%  \documentclass[11pt, handout]{beamer}
 \documentclass[11pt]{beamer}
%\documentclass[11pt, draft]{beamer}

\usepackage{ngerman}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\lstset{language=C++}

\lstset{% general command to set parameter(s)
    basicstyle=\small,          % print whole listing small
    keywordstyle=\color{black}\bfseries,
                                % underlined bold black keywords
    identifierstyle=,           % nothing happens
    commentstyle=\color{black!75},
    stringstyle=\ttfamily,      % typewriter type for strings
    showstringspaces=false}     % no special string spaces



% \usepackage{url}
% \usepackage{multimedia}

%\usepackage{fancybox}

\setbeamercovered{transparent}

\mode<presentation>{
\usetheme{Luebeck}
\useoutertheme{miniframes}
}

\title[avr-halib]{\textbf{avr-halib} \\ Eine Hardwareabstraktion für AVR Mikrocontroller in C++}
\author{Karl Fessel \and Philipp Werner}
\institute{EOS.IVS.FIN.OvGU}

\subject{avr-halib: Eine Hardwareabstraktion für AVR Mikrocontroller in C++}
\keywords{avr-halib, AVR, Hardwareabstraktion, Bibliothek, C++}


\begin{document}


\frame{\titlepage}
\frame{\frametitle{avr-halib}\tableofcontents}


\section{Einführung}

\begin{frame}{avr-halib: AVR hardware abstraction library}


\begin{columns}[t]
	\column{0.33\textwidth}
		\begin{center}{\usebeamerfont*{item}\usebeamercolor[fg]{item}
			AVR
		}\end{center}
		\begin{itemize}
			\item für AVR Mikrocontroller
			\item für avr-gcc toolchain
		\end{itemize}
		

	\column{0.33\textwidth}
		\begin{center}{\usebeamerfont*{item}\usebeamercolor[fg]{item}
			hardware abstraction
		}\end{center}
		\begin{itemize}
			\item Maskierung von Heterogenität
			\item einfache Schnittstelle
		\end{itemize}

	\column{0.33\textwidth}
		\begin{center}{\usebeamerfont*{item}\usebeamercolor[fg]{item}
			library
		}\end{center}
		\begin{itemize}
			\item Bibliothek	% kein OS, mit RT-OS kobinierbar
			\item C++		% in C++ für Programme in C++
		\end{itemize}

\end{columns}

% \begin{itemize}
% 	\item entwickelt von Karl Fessel und Philipp Werner
% 	\item Dank an Michael Schulze
% \end{itemize}

\end{frame}





\begin{frame}{Designziele}
	\begin{itemize}
		\item leichte Portierbarkeit (Anwendung und Bibliothek)
			\begin{itemize}
				\item andere AVR Mikrocontroller
				\item andere Hardwarekonfigurationen % Zuteilung anderer Ports...
			\end{itemize}
		\item einfache Verwendung
		\item geringer Overhead (RAM, Programmspeicher und Laufzeit)
	\end{itemize}
\end{frame}

\section{Konzepte}

\begin{frame}[fragile]{Template-kofigurierbare Klassen (TKK)}
Trennung von allgemeiner Schnittstelle und spezifischer Konfiguration

\begin{lstlisting}
Led<Led0> statusLed;
\end{lstlisting}

\begin{itemize}
	\item Led (Templateklasse): allgemeine Schnittstelle und Algorithmus (z.~B. Setzen, Toggeln, Statusabfrage)
	\item Led0 (Templateparameter): Hardwareschnittstelle via Portmap
	\item statusLed (Objektbezeichner)
\end{itemize}
		

\end{frame}

\begin{frame}[fragile]{Template-kofigurierbare Klassen (TKK)}

\begin{block}{Vorteile}
\begin{itemize}
	\item große Flexibilität (z.~B. Parametrisierung zur Compilezeit)
	\item Komplexität des Quellcodes zur Compilezeit aufgelöst
	\item nur verwendete Funktionen werden generiert
	\item ohne oder geringer Overhead 
\end{itemize}
\end{block}

\begin{block}{Nachteile}
\begin{itemize}
\item bei komplexen Klassen, die mehrfach mit verschiedenen Parametern verwendet werden, wird mehr Code generiert
\end{itemize}
\end{block}

% DDRA |= 0x1;
% while (1)
% 	PORTA ^= 0x1;
% 
% Led<Led0> led0;
% while (1)
% 	led0.toggle();
% Flexibler, besser lesbar, generierter Programmcode gleich
\end{frame}



\begin{frame}[fragile]{TKK: AVR-Klassen und Registermaps}
	\begin{block}{AVR-Klassen}
		\begin{itemize}
			\item abstrahieren AVR-Komponenten (ADC, Timer, Uart, Ports...)
			\item Konfiguration und prozessorspezifische Implementierung über Registermaps (Template-Parameter)
		\end{itemize}
	\end{block}
\begin{block}{Beispiel:}
\begin{lstlisting}
Uart<Uart1> uart;
uart.put("A");
\end{lstlisting}
\end{block}


\end{frame}


\begin{frame}[fragile]{TKK: Device-Klassen und Portmaps}

	\begin{block}{Device-Klassen}
		\begin{itemize}
			\item abstrahieren externe Hardware, die über Ports angesprochen wird (LEDs, Buttons, LCD...)
			\item Konfiguration über Portmaps (Template-Parameter)
		\end{itemize}
	\end{block}
 
	\begin{block}{Portmaps}
		\begin{itemize}
			\item Hardware-Pins werden funktionelle Bezeichner zugeordnet
			\item Definition in spezieller Syntax
			\item automatische Generierung des C++-Codes
		\end{itemize}
	\end{block}

\end{frame}


\begin{frame}[fragile]{TKK: Schnittstellenvereinfachung}
	Zusatzfunktionen und/oder vereinfachte Anwendung für AVR- oder Device-Klassen

\begin{block}{Beispiel: CDevice}
	\begin{lstlisting}
		CDevice< Uart<Uart1> > uart;
		int32_t a, b;
		uart.readInt(a);
		uart.readInt(b);
		uart << a << "+" << b << "=" << (a+b) << "\n";
	\end{lstlisting}
\end{block}

\end{frame}



\begin{frame}[fragile]{Delegates}

	Verwendung von Delegates für Interrupts

	\begin{itemize}
		\item C-Funktionen und Objektmethoden als ISR
		\item ISR zur Laufzeit austauschbar (mit AVR-libc nicht möglich!)
		\item skaliert gut
	\end{itemize}

\begin{block}{Beispiel:}
	\begin{lstlisting}
class foo {
public:   void dot() { /* ISR */ }
};

int main() {
  foo hallo;
  redirectISRM(SIG_INTERRUPT3, &foo::dot, hallo);
}
	\end{lstlisting}
\end{block}

\end{frame}



\section{Verwendung}


\begin{frame}{Ordnerstruktur}

\begin{small}\begin{itemize}
	\item \textbf{build}: zu linkende Bibliothek
 	\item \textbf{docs}: Dokumentation
	\item \textbf{examples}: Beispiel-Programme
	\item \textbf{include}: der größte Teil der Bibliothek befindet sich hier 
	\begin{itemize}
		\item \textbf{avr}: Abstraktion der Mikrocontrollerkomponenten (z.~B. Port, ADC) und Interrupt-Mechanismus
		\item \textbf{ext}: Abstraktion von externen Komponenten (z.~B. LED, Sensor)
		\item \textbf{share}: gemeinsam genutzte Klassen, Klassen zur vereinfachten Verwendung von Klassentypen (z.~B. Sensoren, zeichenorientierte Kommunikation)
		\item \textbf{portmaps}: Häufig verwendete Portmaps (z.~B. RobbyBoard)
	\end{itemize}
	\item \textbf{src}
	\item \textbf{tools}: Portmap-Generator
\end{itemize}
\end{small}\end{frame}


\begin{frame}[fragile]{Erste Schritte}
\begin{enumerate}
	\item \verb!avr-halib$ make!
	\item Beispiele unter \verb!avr-halib/examples/application! anschauen
	\item Ordner für Projekt und cc/cpp-Datei anlegen und Makefile schreiben (oder von Examples kopieren und anpassen)
	\item Includes für benötigte Komponenten und eigenen Quellcode einfügen, ggf. nötige Portmaps erstellen
\end{enumerate}
\end{frame}


\begin{frame}[fragile]{Beispielprogramme}
~~
\end{frame}


\section{Status und Planung}
\begin{frame}[fragile]{Status und Planung}

\begin{block}{Status}
\begin{itemize}
	\item Ports, Interrupts, Uart, ADC, einfacher Timer, Buttons, Leds, Sensoren, SHT-Sensoren, Motor, LCD
	\item Dokumentation für Portmap-Konzept und einige Klassen
\end{itemize}
\end{block}

\begin{block}{Planung}
 \begin{itemize}
	\item Code aufräumen und dokumentieren
	\item I2C-Bus
	\item Timer-Implementierung
\end{itemize}
\end{block}

\end{frame}


\section{Fragen}
\begin{frame}[fragile]{Fragen}
\begin{center}
\begin{Huge}\begin{Huge}???\end{Huge}\end{Huge}\end{center}
\end{frame}



\end{document}

